/*
 * Generated by breeze-generator (https://github.com/weibreeze/breeze-generator)
 * Schema: testmsg.breeze
 * Date: 2019/6/12
 */

#include "testmsg.breeze.h"

MyEnum::MyEnum() {
    schema_ = std::make_shared<BreezeSchema>(BreezeSchema{});
    schema_->name_ = "motan.MyEnum";
}

MyEnum::MyEnum(const EMyEnum &e) : value_(e) {
    schema_ = std::make_shared<BreezeSchema>(BreezeSchema{});
    schema_->name_ = "motan.MyEnum";
}

bool operator==(const MyEnum &a, const MyEnum &b) { return a.value_ == b.value_; }

bool operator==(const MyEnum &a, const MyEnum::EMyEnum &b) { return a.value_ == b; }

bool operator==(const MyEnum::EMyEnum &a, const MyEnum &b) { return a == b.value_; }

bool operator!=(const MyEnum &a, const MyEnum &b) { return a.value_ != b.value_; }

bool operator!=(const MyEnum &a, const MyEnum::EMyEnum &b) { return a.value_ != b; }

bool operator!=(const MyEnum::EMyEnum &a, const MyEnum &b) { return a != b.value_; }

MyEnum &MyEnum::operator=(const MyEnum::EMyEnum &a) {
    this->value_ = a;
    return *this;
}

int MyEnum::write_to(BytesBuffer *buf) const {
    return breeze::write_message(buf, schema_->name_, [this, buf]() {
        breeze::write_message_field(buf, 1, int32_t(this->value_));
    });
}

int MyEnum::read_from(BytesBuffer *buf) {
    return -1;
}

int MyEnum::read_enum(BytesBuffer *buf) {
    int number;
    auto err = breeze::read_message_by_field(buf, [this, &number](BytesBuffer *buf, int index) {
        if (index == 1) {
            return breeze::read_value(buf, number);
        } else {
            return -1;
        }
    });
    if (err != 0) {
        return err;
    }
    switch (number) {
        case 1:
            this->value_ = E1;
            break;
        case 2:
            this->value_ = E2;
            break;
        case 3:
            this->value_ = E3;
            break;
        default:
            return -1;
    }
    return 0;
}

std::string MyEnum::get_name() const { return schema_->name_; }

std::string MyEnum::get_alias() { return schema_->alias_; }

std::shared_ptr<BreezeSchema> MyEnum::get_schema() { return schema_; }

void MyEnum::set_name(const std::string &name) {}

TestMsg::TestMsg() {
    schema_ = std::make_shared<BreezeSchema>(BreezeSchema{});
    schema_->name_ = "motan.TestMsg";
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{1, "myInt", "int32"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{2, "myString", "string"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{3, "myMap", "map<string, TestSubMsg>"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{4, "myArray", "array<TestSubMsg>"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{5, "subMsg", "TestSubMsg"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{6, "myEnum", "MyEnum"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{7, "enumArray", "array<MyEnum>"}));
}

int TestMsg::write_to(BytesBuffer *buf) const {
    return breeze::write_message(buf, schema_->name_, [this, buf]() {
        if (this->myInt != 0) {
            breeze::write_message_field(buf, 1, this->myInt);
        }
        if (!this->myString.empty()) {
            breeze::write_message_field(buf, 2, this->myString);
        }
        if (!this->myMap.empty()) {
            breeze::write_message_field(buf, 3, this->myMap);
        }
        if (!this->myArray.empty()) {
            breeze::write_message_field(buf, 4, this->myArray);
        }
        breeze::write_message_field(buf, 5, this->subMsg);
        breeze::write_message_field(buf, 6, this->myEnum);
        if (!this->enumArray.empty()) {
            breeze::write_message_field(buf, 7, this->enumArray);
        }
    });
}

int TestMsg::read_from(BytesBuffer *buf) {
    return breeze::read_message_by_field(buf, [this](BytesBuffer *buf, int index) {
        switch (index) {
            case 1:
                return breeze::read_value(buf, this->myInt);
            case 2:
                return breeze::read_value(buf, this->myString);
            case 3:
                return breeze::read_value(buf, this->myMap);
            case 4:
                return breeze::read_value(buf, this->myArray);
            case 5:
                return breeze::read_value(buf, this->subMsg);
            case 6:
                return breeze::read_value(buf, this->myEnum);
            case 7:
                return breeze::read_value(buf, this->enumArray);
            default:
                return -1;
        }
    });
}

std::string TestMsg::get_name() const { return schema_->name_; }

std::string TestMsg::get_alias() { return schema_->alias_; }

std::shared_ptr<BreezeSchema> TestMsg::get_schema() { return schema_; }

void TestMsg::set_name(const std::string &name) {}

TestSubMsg::TestSubMsg() {
    schema_ = std::make_shared<BreezeSchema>(BreezeSchema{});
    schema_->name_ = "motan.TestSubMsg";
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{1, "myString", "string"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{2, "myInt", "int32"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{3, "myInt64", "int64"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{4, "myFloat32", "float32"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{5, "myFloat64", "float64"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{6, "myByte", "byte"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{7, "myBytes", "bytes"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{8, "myMap1", "map<string, bytes>"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{9, "myMap2", "map<int32, array<int32>>"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{10, "myArray", "array<int32>"}));
    schema_->put_field(std::make_shared<BreezeField>(BreezeField{11, "myBool", "bool"}));
}

int TestSubMsg::write_to(BytesBuffer *buf) const {
    return breeze::write_message(buf, schema_->name_, [this, buf]() {
        if (!this->myString.empty()) {
            breeze::write_message_field(buf, 1, this->myString);
        }
        if (this->myInt != 0) {
            breeze::write_message_field(buf, 2, this->myInt);
        }
        if (this->myInt64 != 0) {
            breeze::write_message_field(buf, 3, this->myInt64);
        }
        if (this->myFloat32 != 0) {
            breeze::write_message_field(buf, 4, this->myFloat32);
        }
        if (this->myFloat64 != 0) {
            breeze::write_message_field(buf, 5, this->myFloat64);
        }
        if (this->myByte != 0) {
            breeze::write_message_field(buf, 6, this->myByte);
        }
        if (!this->myBytes.empty()) {
            breeze::write_message_field(buf, 7, this->myBytes);
        }
        if (!this->myMap1.empty()) {
            breeze::write_message_field(buf, 8, this->myMap1);
        }
        if (!this->myMap2.empty()) {
            breeze::write_message_field(buf, 9, this->myMap2);
        }
        if (!this->myArray.empty()) {
            breeze::write_message_field(buf, 10, this->myArray);
        }
        if (this->myBool) {
            breeze::write_message_field(buf, 11, this->myBool);
        }
    });
}

int TestSubMsg::read_from(BytesBuffer *buf) {
    return breeze::read_message_by_field(buf, [this](BytesBuffer *buf, int index) {
        switch (index) {
            case 1:
                return breeze::read_value(buf, this->myString);
            case 2:
                return breeze::read_value(buf, this->myInt);
            case 3:
                return breeze::read_value(buf, this->myInt64);
            case 4:
                return breeze::read_value(buf, this->myFloat32);
            case 5:
                return breeze::read_value(buf, this->myFloat64);
            case 6:
                return breeze::read_value(buf, this->myByte);
            case 7:
                return breeze::read_value(buf, this->myBytes);
            case 8:
                return breeze::read_value(buf, this->myMap1);
            case 9:
                return breeze::read_value(buf, this->myMap2);
            case 10:
                return breeze::read_value(buf, this->myArray);
            case 11:
                return breeze::read_value(buf, this->myBool);
            default:
                return -1;
        }
    });
}

std::string TestSubMsg::get_name() const { return schema_->name_; }

std::string TestSubMsg::get_alias() { return schema_->alias_; }

std::shared_ptr<BreezeSchema> TestSubMsg::get_schema() { return schema_; }

void TestSubMsg::set_name(const std::string &name) {}

